## v-if 和 v-for 哪个优先级，如果两个同时出现，应该怎么优化得到更好的性能

- 结论：v-for 优先级高于 v-if

- 如何得出结论？ 在 vue 源码，genElement 方法中，el.for 的判断和处理优先于 el.if

- 如果同时出现，每次渲染都会先去执行循环，在判断条件，这样的顺序就会造成性能上的浪费，因为有可能很多数据项是 v-if false 的，不需要去循环处理的

- 优化：两种方式

  - 个人推荐，将 v-if 的判断条件写在 computed 中，将 false 的项过滤掉
  - 如果判断方式和项本身没有关系，也可以在外层嵌套 template，然后进行 v-if 判断。内存进行 v-for 循环

- Vue3.0 中已改为 v-if 优先

## vue 组件 data 为什么必须是个函数，而 vue 根实例则没有此限制

1. vue 组件可能存在多个实例，如果使用对象形式定义一个组件的 data，会导致他们共用一个 data 对象，
   某一个组件更改了 data 中的数据就会影响所有其他的组件。这肯定不行
2. 采用函数形式，initData 中会去判断如果传入的 data 是函数，则会将最终的 data 等于函数的返回值，每个实例就会生成一个新的对象了，就可以有效规避多实例之间的状态污染问题了

3. 根实例创建过程中不存在该限制，因为根实例只有一个

4. 如果问 props 或者 methods 这种为啥可以是对象而非函数
   我看过 initProps 方法，它并没有直接采用传入的 props 去做初始化，而是将它作为 propsData，自己新建了一个 prop 对象，所以不会共享一个对象
   methods 本来就应该共享的，方法就是应该要共享的

## key 工作原理，说说对它的理解

1. key 是虚拟 DOM diff 算法很重要的一环，Vue 在进行新旧虚拟 DOM 比对时，就是根据 key 值确定对应关系的。
2. 如果没有写 key 值，默认是按照顺序确认身份
3. 这种模式下，如果你是在列表末尾插入项，那身份对应还是正确的
4. 但是一旦比方说你在头部插入一项数据，那么所有的对应关系全部错误了
5. 对应关系错了会发生什么呢，新旧虚拟 DOM 对比时，会比较标签名，绑定的标签属性，内部值等等。因为对应关系错乱，很有可能这些就产生了变化，导致 DOM 的重新渲染。而实际上，你只是插入了一项，其他几项是不需要改动的，这当然非常消耗性能

## vue 组件化的理解

- 回答思路：组件化定义、优点、使用场景和注意事项

- 什么是组件化：组件化就是将实现页面某一部分功能的结构、样式和逻辑,封装成为一个整体，使其高内聚，低耦合，达到可复用的目的
  对于 Vue 来说，每个页面都可以认为是一颗组件树，功能页面的戏份，就对应子组件树
  组件系统是 vue 核心特性之一，它使得开发者使用小型，独立和通常可复用的组件构建大型应用
- 组件化的优点和好处：
  1. 低耦合、高复用：低耦合，组件就是一个独立的个体，哪个组件出问题修改这个组件即可，不会影响到页面其他模块。高复用是显而易见的，比如一个基础组件几乎用到所有地方。使用 props 维持每个组件实例自身的不多的特殊性
  2. 根据低耦合和高复用，很显然就带来了更好的维护性，逻辑的清晰，代码的可读。然后就是提高研发效率，因为只要是相似功能，一个组件开发完，后续都只是简单复用就可以了

## 对 vue 设计原则的理解

- 根据官网的描述：vue 是一个渐进式的 javscript 框架。特点是 易用，高效，灵活

- 渐进式：什么是渐进式？

  1. 官方描述：
     与其它大型框架不同的是，Vue 被设计为可以自底向上逐层应用。Vue 的核心库只关注视图层，不仅易于上手,还便于与第三方库或既有项目整合。另一方面，当与现代化的工具链以及各种支持类库结合使用时，Vue 也完全能够为复杂的单页应用提供驱动。
  2. 个人理解：
     不管是对于学习 Vue 还是使用 Vue，可以一点一点来。你可以只使用它的核心功能，去做视图是数据的关联。对于它的生态一律不采用，当你诉求越来越大时，再慢慢使用它已经为你准备好的功能
     总结来说就是：Vue 它自下而上提供很多选择，但是不做强主张。很多其他库，你要使用它的基础功能，可能不得不引入很多你不需要用到的功能

- 易用：
  vue 提供数据响应式，声明式模板语法和基于配置的组件系统等核心特性，使得我们专注于逻辑处理而不是 DOM 操作。
- 灵活：（和渐进式框架类似的意思）
  渐进式框架: 最大特点就是灵活性, 如果应用足够小, 我们仅就需要 vue 核心特性即可完成功能。 随着应应用规模的不断扩大, 我们才可以逐渐引入路由, 状态管理, vue-cli 脚手架等库和工具。 不管是应用体系还是学习难度都是一个逐渐增加的曲线
- 高效：
  高效呢就是指 diff 算法了，操作 DOM 会引发浏览器的回流和重绘，diff 算法让我们尽可能少的去操作 DOM，这就是高效的体现

## 如何设计一个好的组件

1. 容错处理, 这个要做好, 极端场景要考虑到。起码不能报错影响整体
2. (默认值)要有，只要不是不填整个组件无法运行的参数，都应该设默认值, 一般把应用较多的设为缺省值
3. 颗粒化, 把组件拆分出来
4. 可配置，尽可能灵活
5. 可拓展性，二次封装：这叫要求组件代码不能写的很死。打个比方，就以自定义表单组件来说，肯定要考虑到后续可能还会增加别的类型，对于 vmodel 类型的表单项来说，只需要简单增加对应关系即可运行了，这样的扩展性就很好

## 谈谈你对 MVC MVP 和 MVVM 的理解

这三者都是有 MV 的，M 代表 Model，即数据；V 代表 View 即视图，这两个是比较好理解的，所以在谈下面三个模式的时候，我重点谈论后面的单词

- 这三者都是框架模式，它们设计的目标都是为了解决 Model（数据）和 View（视图）的耦合问题

- MVC

  - C 代表 Control
    Control 层：接收用户所有操作，当用户操作后根据代码逻辑更新 model 层数据，model 层数据更新后自动更新 view 视图

  - MVC 的缺陷：

  1. 大部分逻辑都集中在 Control 层，压力很大
  2. Control 层和 view 层是一一对应的，断绝了 view 层复用的可能

- MVP 框架，P（Presenter 是中间人的意思）
  - 在 MVC 中，view 层通过 Model 层来更新，而在 MVP 中，view 层不能再直接访问 Model 层了，必须通过中间人 P。
  - 这样做的好处是什么？
    1.  完全分离了 view 和 model，甚至都不知道对方的存在。所以 view 层可以抽离出来进行复用
  - 它的问题也很明显，什么事情都由中间人来干，MVP 是没有绑定数据的，因为 view 层和 model 层毫无关系了，是由 P 层手动更新的，所以 P 的压力又太大了

* MVVM 模式如今的前端框架中被广泛应用，所谓 vm，就是自动将数据变化转换为视图更新，并且可监听用户交互修改的视图，转化为数据。简单来说，它鞥能够自动维护两者之间的映射关系，并且是双向的。在提高开发效率、可读性同时还保持了优越的性能表现

## Vue 性能优化方式

1. 对于和视图无关的数据和逻辑，可以分离出来放到 js 里。比方最典型的就是 ajax。一旦在 vue 中定义了变量，vue 就会帮你监听，非常影响性能
2. 路由懒加载
3. 事件销毁,Vue 组件被销毁时，会自动解绑 它的全部指令即自定义事件监听器，但是原生事件的监听不会销毁，最好手动销毁
4. keep-alive 缓存页面
5. 使用 v-show 复用 DOM
6. v-for 遍历时必须指定 key，并且避免使用 v-if
7. SSR 服务端渲染

## vue 动态组件的理解

- 概念：通过 component 组件，is 属性，动态切换组件显示。利用该技术，可以少写很多 v-if 判断。当然如果组件越来越多，可以考虑使用 render 自定义渲染

- 动态组件和普通组件的不同：
  1. ast 阶段新增了 component 属性，这是动态组件的标志
  2. 产生 render 函数阶段由于 component 属性的存在，会执行 genComponent 分支。和普通组件相比，h 函数的第一个参数不再是固定的字符串，而是一个组件名称变量
  3. render 到 vnode 阶段流程基本相同，只是字符串替换成了变量而已，并且增加了 tag：component 的 data 属性

## \$nextTick 原理

- 概念：
  我们知道数据更新和 DOM 更新并不是实时同步进行的，因为性能的问题，会合并多个数据修改，进行一次 DOM 更新
  \$nextTick 就是用来在一次 DOM 更新后，执行传入的回调函数

- 那么它是如何实现的呢？
  其实原理特别简单，\$nextTick 执行了一遍异步任务，因为异步任务肯定晚于同步任务，数据改变到 Vue 内部的 DOM 更新都是同步任务，所以一定会在 DOM 更新后调用

- 关键：
  问题的关键，异步任务也分为宏任务和微任务，在这里当然最好是使用微任务，因为微任务是快于宏任务的。在 DOM 更新后越快执行回调是越好的

  1. 所以 Vue 优先选择 Promise，差不多是最常见的微任务，环境支持 Promise 就通过 Promise 延迟执行
  2. 如果不支持 Promise 就使用 MutationObserver，MutationObserver 会在指定的 DOM 发生变化时触发回调，变化可以是属性变化，子孙节点变化等
  3. 上面这两种其实在 IE 下都是不支持的，那么在判断是否支持 setImmediate，该方法只有 IE 和 Node 环境支持，在浏览器环境下其实是不推荐使用的，是一个非标的 API
  4. 如果 setImediate 不支持，那么最后就是用 setTimeout(0)

  - 顺便说下，现在可以使用一个新的产生微任务的 API，queueMicrotask，也可以用来生成微任务

## keep-alive

- 使用：
  keep-alive 的使用只需要在动态组件的最外层添加标签即可，也可放在路由 router-view 外层，缓存路由切换结果

  ```
      <keep-alive>
        <component :is="chooseTabs">
        </component>
    </keep-alive>
  ```

- keep-alive 和其他组件的不同：
  组件生成时，只保留 slot 属性，其他属性是没有意义的，比方说 class 属性等

- keep-alive 组件的渲染流程：
  1. 获取 keep-alive 下插槽的内容，也就是 keep-alive 需要渲染的子组件
  2. 判断组件是否满足匹配条件，
     匹配条件就是 keep-alive 组件的两个 props，include 和 exclude，匹配规则允许使用字符串、数组和正则
     当然还有一个 max，可以限制缓存的组件个数
     如果没有满足匹配条件，那么直接返回第一步中拿到的子组件 vnode，去创造子组件，子组件创造过程中发现没有 keepAlive 为 true 的属性，所以会调用 createComponentInstanceForVnode 方法进行组件实例化，并将组件实例赋值给 vnode。
     如果满足条件，继续往下
  3. 即缓存子组件 vnode，这里 vue 使用了两个变量，对象 cache 和数组 keys，数组 keys 主要是用来判断缓存的组件是否已经超过设置的 max 值。对象 cache 就是以 Vnode 的 key 作为属性，缓存子组件的 vnode，在 vnode 的 data 属性上打上标记 keepalive 为 true。
  4. 组件实例化
     1. 如果判断缓存中已经有该虚拟 DOM 了，就会将第一步取出来的 vnode 的 componentInstance 属性指向缓存中的 vnode 的 componentInstance 属性。
     2. 如果未缓存，则会调用 createComponentInstanceForVnode 方法进行组件实例化，并将组件实例赋值给 vnode 的 componentInstance 属性。所以说会有一系列生命周期
  5. vnode 保存的属性中是带有真实 DOM 的，真实 DOM 是比较庞大的，所以说是不建议缓存大量组件的。一般来说还是设置 max 的值对性能会好一些

## Vue3.0 性能提升体现在哪里？

性能在编译、源码体积和响应式系统中均有体现

- 编译

  1. diff 算法优化
     Vue3 的 diff 算法对比 Vue2 增加了静态标记，即如果一组 DOM，有一部分没有绑定上数据，那么 diff 算法不会比较这部分 DOM
  2. 静态提升：
     Vue3 中对不参与更新的元素，会做静态提升，只会被创建一次，在渲染时直接复用缓存。免去了 Vue2 中的重复创建节点过程

- 源码体积：移除一些不常用的 API，更重要的是 Vue3 更好的支持了 Tree shaking，Vue3 任何一个暴露的函数，如果没有被用到都会被树摇掉

- 响应式系统
  1. vue2 中采用 defineProperty 来劫持整个对象，然后进行深度遍历所有属性，给每个属性添加 getter 和 setter，实现响应式
  2. vue3 采用 proxy 重写了响应式系统，因为 proxy 可以对整个对象进行监听，所以不需要深度遍历
     并且 proxy 还有以下优点：可以监听属性的添加和删除，监听数据的类型更丰富，比如数组类型。可以监听数组的索引和 length 属性

## 数组同样可以利用 Object.defineProperty 监听，Vue 为什么不用？

因为 Object.defineProperty 只能监听到直接对属性进行 get 和 set，而数组中存在大量的对象属性添加和删除或者其他操作，如 push 和 splice、reverse 等等，所以你只监听数组元素的获取和索引取值意义是不大的。

## 说说 Vue 的数据绑定原理

- 解答顺序：先说核心原理：对象的 defineproperty/数组的重写方法
  再说下依赖收集/依赖分发

1. template 中的模板进行词法分析，具体呢就是扫描模板字符串，利用栈结构完成模板解析，核心就是根据开始标签入栈节点，结束标签出栈节点，然后将这之间的节点信息提取出来作为属性保存。一个节点用一个对象保存。它的子节点就作为 children 保存。
2. 所以就把 template 根据其自身的结构解析成了一颗对应的树，这颗树就是 AST 抽象语法树了，即用 js 对象去描述 DOM 节点，这个对象里保存着基本的如节点类型、节点名、节点属性，还有 Vue 专属的指令等信息
3. 有了 AST 抽象语法树，就可以构建 render 函数了（构建 render 函数的目的是为了执行 render 函数，生成虚拟 DOM）。这个 render 函数根据不同的模板肯定是不一样的，所以需要动态构成，可以使用 new Function 创建一个动态函数，这里有一个注意点，new Function 创造的函数作用域是在全局，所以如果不做处理，它是无法访问其他作用域的变量的。那么有两个解决方案，第一个将其他变量以参数传入，第二使用 with 改变作用域，Vue 中就是用了 with 方法，with(this)，将内部变量都在 this 对象上取值，而 this 的一个指向比较好控制，通过 call 或 apply 就可以了
4. 创建 render 函数是一个递归的过程：可以从创建模板根节点虚拟 DOM 分析：即调用 h 函数，传入对应的参数，即节点名(tag)，节点属性（data）,最后使用数组存放节点的子节点。上述过程都要使用字符串表示
5. 那么子节点是需要进行详细处理的，它呢大致可分为三类：

   1. 第一类节点类型为文本类型，并且是纯文本，即没有双大括号，那么直接把节点的 text 属性作为字符串返回，注 意这是字符串内的字符串，一层字符串最后执行时代表变量。
   2. 节点类型为文本类型，并且带有双大括号，那么双大括号内的变量，就不能用字符串再次包裹了，因为它在执行时 就需要被当做变量，这个双大括号内的字符串解析，其实是很复杂的过程，需要 token 化，因为它内部可以写 js 表达 式，可以包含过滤器等等一些列复杂的内容。就不详细展开了
   3. 节点类型依然是一个元素节点，那么再次调用一遍本函数，传入的 ast 为 child 自身

   - 这就是动态 render 函数的一个大概创建过程。当双花括号内存在变量时，对于该变量，就需要调用 Watcher 类对其进行监听，同时也是一个依赖收集的过程，即该变量再次被调用了，一旦变量有改动，就需要通知到 Vue 去更新这部分视图

6. 然后就是调用 render 函数，根据模板和数据渲染出视图。模板中双花括号内的变量会被 data 定义的变量所取代。又因为使用了 Watcher 监听，所以能够监听到该值的改变，一旦被 set，就会通知视图更新

7. 再详细介绍下监听部分，监听部分主要是由 Watcher 类，Dep 类和 Objserver 三个类构成。刚刚创建 render 函数渲染时提到了，一旦 render 函数内调用了某个 data 中的变量，就会调用 Watcher 类进行依赖收集工作。

   1. 依赖收集：除了在花括号内使用变量，又比如指令当中 v-model，也需要对变量进行依赖收集，也就是说任何用到变量的地方，都需要调用 Watcher 类进行依赖收集。Watcher 类内部主要做两件事，第一件将 Dep.target 设置为当前 Watcher 类，其实这就是一个全局对象。第二件事访问 data 中的要监听的属性。
   2. 一旦访问了该属性，因为在初始化时，通过调用 observe 方法，observe 又会去 new Observer 实例，Observer 内部会遍历 data 属性，将 data 上的属性通过 defineProperty 监听，对于数组类型的属性，通过改写数组的更改值的方式实现监听。一旦访问了属性，就会进入到 get 中，所以和依赖收集联系起来，Watcher 会去访问 data 的属性，一旦访问了就会被 get 捕捉到，get 中就会将 Dep.target push 到该属性的 Dep 类中。实现了依赖收集

   3. 更新派发：一旦该属性被修改，就拿出该属性的 Dep 类，遍历并且通知每个依赖属性被修改了，通过 update 方法更新，并传入更改后的值。Wahcer 类的调用者通过回调函数得知更新，就会重新执行该节点的 render 函数，并且赋予新值，此时就有了新老两个虚拟节点，最后一步就是最经典的新老虚拟节点对比，真实 DOM 更新，这一步在 patch 函数中

8. patch 函数（新旧虚拟 DOM 更新）

   1. 判断是否为同一个虚拟节点，即 sel 和 key 是否相同，如果不是那么直接删除旧的更新新的
   2. 判断它的节点值类型，如果某一项只有文本节点，也比较简单，比如新虚拟节点文本，旧虚拟节点是多个子节点，那么直接将真实 DOM 清空，填入新的文本。如果是另外一种情况也一样，删除文本，填入新的子节点（createElement 函数）
   3. 节点都具有多个子节点，此时最复杂，需要进行 diff 算法比较

9. diff 算法：目的就是高效匹配，新虚拟子节点和旧虚拟子节点之间尽可能地进行更高效地匹配

   - 内部算法：双指针法：前后指针进行匹配过程。实际上这里有四个指针，因为有两组数据，两个数组。但是从算法上看，每个数组还是前后指针的这样一种思维。把两组数据的前后指针关系起来，就是 diff 算法的巧妙之处
   - 循环终止条件：前后指针经典的终止条件前指针大于了后指针，对于两组数据来说，任意一组达到这个条件即循环终止。那么他们分别代表什么意思呢：

   1. 旧子节点数组前后指针相遇，说明旧子节点已经全部被匹配了，此时如果新子节点数组前后指针还未相遇，说明中间的子节点是新增的
   2. 新子节点数组前后指针相遇，说明新子节点已经全部被匹配了，此时如果旧子节点数组前后指针还未相遇，说明

   - 四种匹配（一旦匹配上就不再往下匹配，指针移动）：
     1. 新前与旧前
     2. 新后与旧后
     3. 新后与旧前，测试方式匹配上了，需要移动真实 DOM，因为节点顺序发生了变化
     4. 新前与旧后，同 3，需要移动真实 DOM
   - 效率：开发中最常见的就是元素有改动，这种情况第一种匹配搞定。如果列表中增加项，增加项中又以在末尾添加最常见，这种情况只需要用到第一种匹配，如果是在中间添加，则添加位置前的元素使用第一种匹配，添加位置后的元素使用第二种匹配。所以开发中最常用的情况都是能够快速匹配的，diff 算法的效率提升在这里就可见一斑了
   - 后两种匹配是针对元素顺序有改动的情况，元素顺序改动并不是很常见，应该也是基于日常和调查总结出来的经验

   - 未匹配上：四种匹配显然不包含所有情况，很明显是对新旧列表的开头和结尾进行匹配，一旦旧元素移动到中间很容易匹配不上。未匹配上时根据剩余指针情况，遍历匹配。即要匹配的新节点在未匹配的旧节点指针遍历匹配。并且做了缓存，下一次匹配该旧节点时可以直接取缓存
     1. 遍历指针
     2. 做旧节点指针缓存
     3. 如果遍历匹配上，则需要移动位置，旧节点移动到未匹配节点的第一位，这样指针移动和节点才会对应
     4. 如果遍历也未匹配上，说明新节点需要新增，通过 creaElement 新增

- 相关题目：ABC => BCA 有几次 DOM 操作
  - 分析：diff 算法的前两种匹配只有值更新，后两种匹配涉及到 DOM 移动（利用 insertBefore），这里 ABC 显然值没有改变。所以关键是看它是否由匹配成功，并且是前两种匹配还是后两种匹配
  - 第一次匹配，新前与旧前，新后与旧后都无法匹配。第三种新后与旧前成功匹配，需要进行一次节点移动
  - 第二第三次匹配均可以通过新前与旧前匹配，无 DOM 操作。所以是 1 次 DOM 操作
  - 如果没有设 key 值，就是按顺序匹配，ABC - BCA，每一次的节点值都不相同，需要重新赋值，所以是三次 DOM 操作

## 说一说 vuex 的实现原理

- vuex 的设计思想：将数据存放到一个全局对象 store 中，再将 store 挂载到每个 vue 实例组件中，利用 vue 自带的响应式系统进行状态更新
- 如何实现挂载到每个组件中：在 vuex 安装时，通过全局混入（mixin），在 beforeCreate 生命周期函数执行时，将 store 赋值给组件实例，那么这个 store 从哪里来，如果你在 options 里传入了 store，那么它会取你传入的 stroe，如果你未传入则取父元素的 store，因为配置了 vuex 的话，势必会在根实例上面添加 store，这样一层一层往下传输，每个组件实例都有了 store 属性
- 响应式的实现：
  在 store 对象上新建了一个 Vue 实例 vm，然后在该 Vue 实例 的 data 里添加了 state，vuex 的数据就存储在这个 state 里，然后做了一层数据代理，访问 store.state 即访问 store 上的 vm 的 data 的 state，所以就有了响应式

## 说一说 vue-router 的实现原理

vue-router 的原理主要包含两部分，第一部分是注入，另一个是路由劫持（这个和 single-spa 的原理非常像）和路由更改

### 注入

- 安装时全局注入 Mixin，在组件的 beforeCreate 钩子函数中执行逻辑。对于传入了 router 的配置来说，就会进行 Vue-router 类的初始化（一般就是根组件传入），对于它的后代组件，其实未做特别处理，只是把根路由组件\_routerRoot 一层一层传递下去

- 其他后代组件如何拿到$router和$route 呢，其实是在 Vue 的原型 prototype 上绑定了这两个属性，并且设置了他们的 get，get 的时候就是去访问\_routerRoot 上的$router和$route

- $router 其实就是我们传入插件的 vue-router 实例
- $route 可以认为是当前活动的路由对象，即存放匹配上当前 url 信息的一个对象，并且这个对象在 install 时已经利用 defineReactive 进行了深度监听

### 路由劫持和路由更改

- 路由更改：这里首先要明确，更改路由不能引起页面请求。这一点怎么搬到

  1. hash 模式下天然如此：在 url 请求时，hash 后面的值是被忽略的，hash 值只是作为前端的一个辅助工具。所以 hash 路由的改变本来就不会向服务端重新发起请求。所以 hash 路由直接修改即可，即将 location.hash 赋值
  2. history 模式下利用 pushState 和 replaceState 这两个新增的 API，他们可以改变非 hash 部分的 url，但是不会引起项服务端重新发起请求，这就是路由更改部分的关键点

- 路由劫持：为什么要劫持劫持路由，因为路由的更改不一定是由程序主动发起的，主动发起的更改从根本上将内部肯定可以监听，但是还有可能是理由浏览器的地址栏手动输入引起更改，或者通过前进后退按钮引起更改

  - 所以需要事件去监听这些更改，那么核心就是利用 hashchange 和 popstate 事件去进行监听。但是注意下 pushState 和 replaceState 是无法除法 popstate 事件的，所以 Vue-router 给你提供 push 和 replace 方法，目的就是让你使用它内部的方法让它实现这两个漏网之鱼的监听。如果你自己调用这两个方法去改变路由，Vue 是不会进行页面跳转的
  - 可以顺便说下，single-spa 的关键部分也有路由劫持，那么它对于这两个漏网之鱼的处理和 Vue 对于 Array 的监听原理类似，就是去重写了 pushState 和 popState 方法，一旦你调用了，其实是调用了它重写后的方法，这种方式实现监听

- 监听到变化后，就会更新当当前活动的路由对象 route，那么在 install 的时候已经对他实现监听了，一旦 history 内部更新了 route，根组件就会监听到变化，那么 router-view 组件就会重新 render，生成新的页面

### vue-router 其他面试题

- active-class 是哪个组件的属性？
  vue-router 模块的 router-link 组件

- 如何定义动态路由，获取路由参数？
  - 动态路由这块和 koa 框架的动态路由感觉比较像，通过:id（获取其他变量名定义）
  - 这样定义后，只要前面部分的 url 匹配上了，就认为整个路由匹配了
  - 获取参数：可以通过 router 对象上的 params 变量获取，你定义了 id 就 params.id

## slot 的理解

个人理解：slot 给你开了一个口子，可以允许外部自定义这个口子内的模板结构

1. 默认插槽：父组件中直接添加自定义的模板结构，组件中用节点 slot 决定自定义内容的位置

2. 具名插槽：目的是当有多个插槽时可以区分：

   - 父组件：通过 temlate 组件，v-slot 指令告知子组件插槽名称，顺便说下默认插槽就是名为 defalt 的具名插槽，两者是一样的
   - 子组件：也是通过 slot 组件决定具名插槽的位置，在 slot 上设置 name 属性定义插槽名称

3. 作用域插槽：目的是解决父组件中想要使用子组件内部数据

   - 父组件：通过 v-slot 的值，比如 v-slot = X，X 的值即是组件内部传入的，可以理解为 slot 的 props
   - 子组件：通过在 slot 节点上绑定属性实现传值，和 props 类似

4. 当然插槽口可以后备内容，就是给个默认结构，如果外部没有自定义，就是用组件内默认的模板

### slot 的原理

1. 父组件优先解析，父组件的解析和其他节点类似，组件被当做某个后代解析，然后插槽的内容，会被解析为 scopedSlots，scopedSlots 里面存放着生成 slot 模板的函数
2. 子组件解析，当解析到 slot 的时候，相应地就会去调用父组件放置在 scopedSlots 内的函数。传入函数名称，如果是作用域插槽，在传入响应数据，生成虚拟 DOM。这样子组件中的 slot 也被成功渲染出来了。

## Vue3 有哪些新特性？

1. 组合式 API，setup 函数，现在又升级为 script 中添加 setup 属性的方式
   在这种模式下，我们就像在写纯粹的 js 一样，使用 ref 或者 reactive 定义的变量直接在页面上使用即可，可以把与之相关的逻辑放在一起，不需要在 data 里定义，在 method 书写逻辑了，也不需要再一直写 this 了。
   - toRefs 对象的作用是将一个 reactive 定义的对象转化为属性全部被 ref 调用的普通对象，其实它是在 setup 函数中的返回值里使用的比较多，通过结构赋值后，就可以直接使用对象属性了，在模板中可以减少一层调用
   - setup 生命周期早于 beforeCreate
   - 组合式 API 中使用 watch，computed 等等和以前相似，只是语法上稍有调整
   - 新增了像 watchEffect 和 readOnly 等等，watchEffect 比较类似 computed，只不过它不关注生成值，只关注监听过程，readOnly 顾名思义，就把一个对象变为外部不可更改的
2. 自定义 Hooks
   - 这个就是 Vue3 非常重要的一点，逻辑的集中处理。和 Vue2 的 Mixin 类似。Mixin 还是有一些缺陷和限制。比方说和 Vue 组件的 options 一样的结构。容易造成命名冲突；Mixin 多了以后，变量的来源以及引起更改混乱等一系列问题
   - 那么 Vue3 的自定义 Hook 就不存在这些问题，变量的定义，响应式，逻辑处理全部封装在一个 js 中，写的时候就和写普通 js 文件一样，没有格式限制。使用的时候引入即可使用，一般约定 hook 以 use 开头
3. Teleport（传送） 组件
   - 它的作用是将组件内部的内容渲染到指定的 DOM 中
   - 场景：比方说最常见的就是弹框，虽然我们使用的时候是在某个组件里使用的，但是一般来说我们希望它被渲染到全局，就可以使用这个组件将弹框包裹，然后把 to 属性设置为 body 或者其他你想移动的位置
4. Suspense：它的作用是在一个异步组件渲染完成之前有一个后备内容（异步组件可以使用 defineComponent API 定义，返回一个 Promise）
   组件内部提供两个插槽，defalut 和 fallback，加载完成前展示 fallback 插槽内的内容，加载完成后展示 default 插槽内的内容
5. 更好的 Tree-Shaking
   - 这也是 Vue 源码体积有效减少的原因，也是目前各种库的一个趋势，比如 Eachrts，从 Echarts4 到 Echarts5，也基本上是做了类似的处理
   - 具体处理：在源码 API 暴露时，使用具名暴露，即 export 某个方法，引入时同样要具名引入，而不再像之前一样，把所有的属性和方法绑定在一个对象上暴露。这样的目的就是为了更好的支持树摇，如果你只暴露了一个方法，打包工具比较难以判断这个对象上的哪个方法被使用了，哪个没有使用。那么如果是具名导出就很清晰了，该方法有没有被引用，引用后有没有被使用。可以更容易的判断
6. 在原型上绑定的属性和方法，大多都移动到了 APP 实例上
   如 Vue.component、Vue.directive 等等

## Vue 事件绑定和事件触发

- 事件绑定（事件监听）：使用 v-on 指令，一般简写为@
- 事件触发：使用$emit 在组件内部实现事件触发

- Vue 中监听的事件在组件被销毁时，Vue 会自动帮你移除监听

- 但是原生事件是不会的，所以原生事件监听最好在 destroy 自己去移除下

## @click 和 addeventListen 哪个先触发

1. @click 是自定义事件，它的触发依赖于程序什么时候取触发，这种我不太理解怎么比较，因为一个是用户操作，一个是程序内部自己触发。
2. 如果说在用户点击这个组件后，我再组件内部调用$emit，那当然是 addeventListen 先触发。或者说你使用的是@click.native，这种情况下我认为也是 addeventListen 先触发，原因就是只有浏览器有监听用户鼠标点击的能力。Vue 是没有办法知道的，它知道点击肯定也是浏览器告诉他的，所以 addeventListen 先触发
3. 如果@click 只是一个单纯的自定义事件，那么它可以在任何时候触发，这种是没办法比较的，就看你程序内部时候去触发它
