## v-if 和 v-for 哪个优先级，如果两个同时出现，应该怎么优化得到更好的性能

- 结论：v-for 优先级高于 v-if

- 如何得出结论？ 在 vue 源码，genElement 方法中，el.for 的判断和处理优先于 el.if

- 如果同时出现，每次渲染都会先去执行循环，在判断条件，这样的顺序就会造成性能上的浪费，因为有可能很多数据项是 v-if false 的，不需要去循环处理的

- 优化：两种方式

  - 个人推荐，将 v-if 的判断条件写在 computed 中，将 false 的项过滤掉
  - 如果判断方式和项本身没有关系，也可以在外层嵌套 template，然后进行 v-if 判断。内存进行 v-for 循环

- Vue3.0 中已改为 v-if 优先

## vue 组件 data 为什么必须是个函数，而 vue 根实例则没有此限制

1. vue 组件可能存在多个实例，如果使用对象形式定义一个组件的 data，会导致他们共用一个 data 对象，
   某一个组件更改了 data 中的数据就会影响所有其他的组件。这肯定不行
2. 采用函数形式，initData 中会去判断如果传入的 data 是函数，则会将最终的 data 等于函数的返回值，每个实例就会生成一个新的对象了，就可以有效规避多实例之间的状态污染问题了

3. 根实例创建过程中不存在该限制，因为根实例只有一个

4. 如果问 props 或者 methods 这种为啥可以是对象而非函数
   我看过 initProps 方法，它并没有直接采用传入的 props 去做初始化，而是将它作为 propsData，自己新建了一个 prop 对象，所以不会共享一个对象
   methods 本来就应该共享的，方法就是应该要共享的

## key 工作原理，说说对它的理解

1. key 是虚拟 DOM diff 算法很重要的一环，Vue 在进行新旧虚拟 DOM 比对时，就是根据 key 值确定对应关系的。
2. 如果没有写 key 值，默认是按照顺序确认身份
3. 这种模式下，如果你是在列表末尾插入项，那身份对应还是正确的
4. 但是一旦比方说你在头部插入一项数据，那么所有的对应关系全部错误了
5. 对应关系错了会发生什么呢，新旧虚拟 DOM 对比时，会比较标签名，绑定的标签属性，内部值等等。因为对应关系错乱，很有可能这些就产生了变化，导致 DOM 的重新渲染。而实际上，你只是插入了一项，其他几项是不需要改动的，这当然非常消耗性能

## vue 组件化的理解

- 回答思路：组件化定义、优点、使用场景和注意事项

- 什么是组件化：组件化就是将实现页面某一部分功能的结构、样式和逻辑,封装成为一个整体，使其高内聚，低耦合，达到可复用的目的
  对于 Vue 来说，每个页面都可以认为是一颗组件树，功能页面的戏份，就对应子组件树
  组件系统是 vue 核心特性之一，它使得开发者使用小型，独立和通常可复用的组件构建大型应用
- 组件化的优点和好处：
  1. 低耦合、高复用：低耦合，组件就是一个独立的个体，哪个组件出问题修改这个组件即可，不会影响到页面其他模块。高复用是显而易见的，比如一个基础组件几乎用到所有地方。使用 props 维持每个组件实例自身的不多的特殊性
  2. 根据低耦合和高复用，很显然就带来了更好的维护性，逻辑的清晰，代码的可读。然后就是提高研发效率，因为只要是相似功能，一个组件开发完，后续都只是简单复用就可以了
  3.

## 对 vue 设计原则的理解

- 根据官网的描述：vue 是一个渐进式的 javscript 框架。特点是 易用，高效，灵活

- 渐进式：什么是渐进式？

  1. 官方描述：
     与其它大型框架不同的是，Vue 被设计为可以自底向上逐层应用。Vue 的核心库只关注视图层，不仅易于上手,还便于与第三方库或既有项目整合。另一方面，当与现代化的工具链以及各种支持类库结合使用时，Vue 也完全能够为复杂的单页应用提供驱动。
  2. 个人理解：
     不管是对于学习 Vue 还是使用 Vue，可以一点一点来。你可以只使用它的核心功能，去做视图是数据的关联。对于它的生态一律不采用，当你诉求越来越大时，再慢慢使用它已经为你准备好的功能
     总结来说就是：Vue 它自下而上提供很多选择，但是不做强主张。很多其他库，你要使用它的基础功能，可能不得不引入很多你不需要用到的功能

- 易用：
  vue 提供数据响应式，声明式模板语法和基于配置的组件系统等核心特性，使得我们专注于逻辑处理而不是 DOM 操作。
- 灵活：（和渐进式框架类似的意思）
  渐进式框架: 最大特点就是灵活性, 如果应用足够小, 我们仅就需要 vue 核心特性即可完成功能。 随着应应用规模的不断扩大, 我们才可以逐渐引入路由, 状态管理, vue-cli 脚手架等库和工具。 不管是应用体系还是学习难度都是一个逐渐增加的曲线
- 高效：
  高效呢就是指 diff 算法了，操作 DOM 会引发浏览器的回流和重绘，diff 算法让我们尽可能少的去操作 DOM，这就是高效的体现

## 如何设计一个好的组件

1. 容错处理, 这个要做好, 极端场景要考虑到。起码不能报错影响整体
2. (默认值)要有，只要不是不填整个组件无法运行的参数，都应该设默认值, 一般把应用较多的设为缺省值
3. 颗粒化, 把组件拆分出来
4. 可配置，尽可能灵活
5. 可拓展性，二次封装：这叫要求组件代码不能写的很死。打个比方，就以自定义表单组件来说，肯定要考虑到后续可能还会增加别的类型，对于 vmodel 类型的表单项来说，只需要简单增加对应关系即可运行了，这样的扩展性就很好

## 谈谈你对 MVC MVP 和 MVVM 的理解

这三者都是有 MV 的，M 代表 Model，即数据；V 代表 View 即视图，这两个是比较好理解的，所以在谈下面三个模式的时候，我重点谈论后面的单词

- 这三者都是框架模式，它们设计的目标都是为了解决 Model（数据）和 View（视图）的耦合问题

- MVC

  - C 代表 Control
    Control 层：接收用户所有操作，当用户操作后根据代码逻辑更新 model 层数据，model 层数据更新后自动更新 view 视图

  - MVC 的缺陷：

  1. 大部分逻辑都集中在 Control 层，压力很大
  2. Control 层和 view 层是一一对应的，断绝了 view 层复用的可能

- MVP 框架，P（Presenter 是中间人的意思）
  - 在 MVC 中，view 层通过 Model 层来更新，而在 MVP 中，view 层不能再直接访问 Model 层了，必须通过中间人 P。
  - 这样做的好处是什么？
    1.  完全分离了 view 和 model，甚至都不知道对方的存在。所以 view 层可以抽离出来进行复用
  - 它的问题也很明显，什么事情都由中间人来干，MVP 是没有绑定数据的，因为 view 层和 model 层毫无关系了，是由 P 层手动更新的，所以 P 的压力又太大了

* MVVM 模式如今的前端框架中被广泛应用，所谓 vm，就是自动将数据变化转换为视图更新，并且可监听用户交互修改的视图，转化为数据。简单来说，它鞥能够自动维护两者之间的映射关系，并且是双向的。在提高开发效率、可读性同时还保持了优越的性能表现

## Vue 性能优化方式

1. 对于和视图无关的数据和逻辑，可以分离出来放到 js 里。比方最典型的就是 ajax。一旦在 vue 中定义了变量，vue 就会帮你监听，非常影响性能
2. 路由懒加载
3. 事件销毁,Vue 组件被销毁时，会自动解绑 它的全部指令即自定义事件监听器，但是原生事件的监听不会销毁，最好手动销毁
4. keep-alive 缓存页面
5. 使用 v-show 复用 DOM
6. v-for 遍历时必须指定 key，并且避免使用 v-if
7. SSR 服务端渲染

## vue 动态组件的理解

## slot 的理解

## \$nextTick 原理

- 概念：
  我们知道数据更新和 DOM 更新并不是实时同步进行的，因为性能的问题，会合并多个数据修改，进行一次 DOM 更新
  \$nextTick 就是用来在一次 DOM 更新后，执行传入的回调函数

- 那么它是如何实现的呢？
  其实原理特别简单，\$nextTick 执行了一遍异步任务，因为异步任务肯定晚于同步任务，数据改变到 Vue 内部的 DOM 更新都是同步任务，所以一定会在 DOM 更新后调用

- 关键：
  问题的关键，异步任务也分为宏任务和微任务，在这里当然最好是使用微任务，因为微任务是快于宏任务的。在 DOM 更新后越快执行回调是越好的
  1. 所以 Vue 优先选择 Promise，差不多是最常见的微任务，环境支持 Promise 就通过 Promise 延迟执行
  2. 如果不支持 Promise 就使用 MutationObserver，MutationObserver 会在指定的 DOM 发生变化时触发回调，变化可以是属性变化，子孙节点变化等
  3. 上面这两种其实在 IE 下都是不支持的，那么在判断是否支持 setImmediate，该方法只有 IE 和 Node 环境支持，在浏览器环境下其实是不推荐使用的，是一个非标的 API
  4. 如果 setImediate 不支持，那么最后就是用 setTimeout(0)

## keep-alive
