# Vue 深入学习记录文档

#### 开发一个库时，有两手准备，一个是库的开发，一个是库的测试（使用）

## Mustache 模板引擎

Mustache 可以说是最早的模板引擎，比 vue 早很多，Mustache 是胡子的意思，因为它的嵌入语法是{{}}，就像一个胡子。
Mustache 即可以用于 node，npm 下载，又可以用于浏览器环境，即是 umd，通用的。
Mustcache 可以被用于 html 文件，配置文件，源代码等等很多场景。它的运行得益于扩展一些标签在模板文件中，然后使用一个 hash 字典或者对象对其进行替换渲染。有一个很重要的点，它是无逻辑的。即不能在里面写 if else 等逻辑语句。Vue 也是一种模板引擎，并且更加优雅，学习 Mustache 就是为了先了解下数据-视图的思路。

### 数据-视图的历史

1. 纯 DOM 法：非常笨拙，没有实战价值。
2. 数组 join 法：曾几何时非常流行，是曾经的前端必会知识
3. ES6 中新增的模板字符串
4. 模板引擎：数据-视图的优雅解决方案。

### Mustache 基本语法

1. 插值语法 {{x}}
2. 是否存在(类似 v-if) {{#m}} ... {{/m}}
3. 简单数组循环(类似 v-for) {{#arr}} {{.}} {{/arr}}
4. 对象数组循环(类似 v-for) {{#arr}} {{x}} {{/arr}} -x 即对象内的某个属性

### Mustache 底层核心机理

Mustache 底层核心机理很多都被 Vue 借鉴

重点分为两步：

1. 将模板字符串编译为 tokens 形式（源代码 nestTokens，可以打印出 tokens）
2. 将 tokens 结合数据，解析为 dom 字符串

#### Mustache 库不能用简单的正则表达式思路实现

- 在较为简单的实例情况下，可以使用正则表达式实现。如插值语法
- 但是当情况复杂时，正则表达式的思路就不行了，比如循环语法

#### tokens（象征；代币）

tokens 是一个 JS 的嵌套数组，说白了，就是模板字符串的 JS 表示
它是“抽象语法树(ast)”、“虚拟节点” 等等的开山鼻祖

1. 比如 `<h1>hello {{name1}}</h1>，今天很{{mood}}`
   会被解析为

```
tokens = [
    ["text" ,"<h1>hello "],
    ["name" ,"name1"],
    ["text" ,"</h1>，今天很"],
    ["name" ,"mood"],
]
```

2. 比如

```
 <div>
     <ul id="list">
         {{#arr}}
         <li>{{.}}</li>
         {{/arr}}
     </ul>
 </div>
```

就会被解析为

```
[
    ["test",'<div><ul id="list">'],
    ["#","arr",[
        ["text","<li>"],
        ["name","."],
        ["text","</li>"],
    ]]
]
```

#### 数据结构

栈结构：先进后出（first in last out - FILO），就像往一个容器里放东西，先放的东西会被后放的东西压着，拿出来时需要先拿后放的。

## Mustache 模板引擎总结

总结还是分为二步

1. 将模板字符串转化为 tokens 数组 --嵌套的数组模式，用嵌套的数组来表示 dom 和数据的关系。这一步的实现个人认为算法是最精妙的。使用了栈结构以及引用类型。
2. 用 tokens 数组和数据组装出最后的 dom 字符串。这一步最关键的就是在遇到#号后，需要判断该 token 的数据类型，当类型是数组是需要通过循环递归得到最后的 dom 字符串。这一步纯个人实现

这个简易版的 Mustache，实现了主干功能，对它进行手写确实会收获良多。

<!-- 暂停一下，学习一下JSX -->

## Vue 高阶用法或最佳实践

- 组件和 mixin 对比，使用场景区分
- 组件通信（增加 vuex 和本地存储如 sessionStorage 的对比）
- 渲染函数和 JSX
- vuex 中 mutation 和 aciton 对比
- watch 和 computed 对比
- require.context 运用（如全局组件注册）
- 开发插件
- 开发过滤器

## 虚拟 dom 和 diff 算法

虚拟 dom：用 js 对象描述 DOM 的层次结构。Dom 中的一切属性都在虚拟 Dom 中有对应的属性。
diff 算法：最小量更新。

diff 是发生再虚拟 dom 上的，新老虚拟 dom 进行 diff，算出应该如何最小量更新，最后反映到真正的 dom 上。
原因很简单，直接用真实 dom 比较麻烦且耗性能。

弄懂三个事情：

1. 虚拟 dom 如何被渲染函数（h 函数）产生？手写 h 函数
2. diff 算法原理？手写 diff 算法
3. 虚拟 dom 如何通过 diff 变为真正的 dom，实际上，这一部分是涵盖在 diff 算法里面的。

# 现在很多的源码库都是使用 ts 编写，对 ts 的学习应该提上日程了。

//
snabbdom 是著名的虚拟 DOM 库，是 diff 算法的鼻祖，Vue 源码借鉴了 snabbdom

### 虚拟 dom 有哪些属性？

```js
const vnode = {
  children: [], // 子元素
  data: {}, //属性样式
  elm: undefined, //该虚拟dom真正的dom节点，undefined表示还未上树
  sel: 'div', // 选择器
  text: ''
};
```

### 手写 h 函数
